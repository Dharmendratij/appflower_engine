# AppFlower Documentation

***[5. The Edit View](#edit-view)***

 * [The *&lt;i:view&gt; element - XML header](#edit-view-element)
 * [The &lt;i:title&gt; element](#edit-title-element)
 * [The &lt;i:datasource&gt; element](#edit-datasource-element)
 * [The &lt;i:fields&gt; element](#edit-fields-element)
 * [The &lt;i:field&gt; element](#edit-field-element)
 * [Children of &lt;i:field&gt;](#edit-children-of-field)
 * [The &lt;i:value&gt; element](#edit-value-element)
 * [The &lt;i:tooltip&gt; element](#edit-tooltip-element)
 * [The &lt;i:help&gt; element](#edit-help-element)
 * [The &lt;i:validator&gt; element](#edit-validator-element)
 * [Event Handlers - The &lt;i:handler&gt; elements](#edit-event-handler)
 * [Field bound popups - The &lt;i:window&gt; element](#edit-field-bound-popups)
 * [The code generator](#admin)

***[6. Other elements inside &lt;i:fields&gt;](#other-elements-inside-fields)***

 * [The &lt;i:button&gt; element](#button-element)
 * [The &lt;i:link&gt; element](#link-elemenet)
 * [Arranging fields - The &lt;i:grouping&gt; element](#arranging-fields-element)
 * [Field sets - The &lt;i:set&gt; tag](#field-sets)

## The Edit View	{#edit-view}

The purpose of this View is the same as that of Forms in XHTML: it allows you to fetch user input. The Edit View is used for both creating and modifying data. Its structure is somewhat similar to that of XHTML. The minimal layout of an Edit View can be described in the following way:


	<?xml version="1.0" encoding="utf-8"?>
		<i:view xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
		xsi:schemaLocation="http://www.appflower.com /schema/appflower.xsd" 
		xmlns:i="http://www.appflower.com/schema/" type="edit">
 
  		<!-- Title of the view -->

 	 	<i:title>...</i:title>

 	 	<!-- The Form and user input fields -->

  		<i:fields>
  			<i:field />
			<i:field />
			...
  		</i:fields>

 	</i:view>


As you can see, this is a very simple definition. However, in a real life scenario you will need a bit more to accomplish your task. The following example is the most common configuration for Edit Views, which is typically what you will need.


	<?xml version="1.0" encoding="utf-8"?>
		<i:view xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
		xsi:schemaLocation="http://www.appflower.com /schema/appflower.xsd" 
		xmlns:i="http://www.appflower.com/schema/" type="edit">
 
		<!-- Title of the view -->

		<i:title>My Widget</i:title>

  		<!-- Source of data to be used when modifying records -->

  		<i:datasource>
  		...
  		</i:datasource>

  		<!-- The Form and user input fields -->

  		<i:fields>
  			<i:field />
			<i:field />
			...
  		</i:fields>

  		<!-- View actions -->

  		<i:actions>
    			<i:action />
    		...
  		</i:actions>
  
  		<!-- Fieldsets and order of fields -->

  		<i:grouping>
    			<i:set>
      				<i:ref />
      				...
    			</i:set>
    			...
  		</i:grouping>

  		<!-- Widget help text -->
	  
  		<i:description>...</i:description>

	</i:view>

As shown in the previous example, most of the elements in an Edit View are optional. The two mandatory elements are ***&lt;i:title&gt;*** and ***&lt;i:fields&gt;***. Please note that other Edit View-related elements and settings exist, but we do not describe them here because they are completely optional and rarely used. In the following section, we will introduce the most common elements and their usage. (For a complete description of all Edit View elements and settings, please see Appendix A.)

Let us examine the example above and discuss the elements one by one:

Please note that some tags are non-View-specific elements and therefore are used in multiple Views. The basic syntax of such tags is the same everywhere, but some also have View-specific constraints. We will discuss the View-related parts in the introduction of each View and you can find all general information tags in the "Non-View-Specific Elements" section. 

Shared tags will be marked with an asterisk.

### The *&lt;i:view&gt; element - XML header	{#edit-view-element}

As you can see, the header section is the same in both examples. In fact, most of this XML code is always the same, regardless of what View is used. The only dynamic part is the type's attribute value. This needs to be defined according to the type of View you are working on. The Edit View always has the value "edit".


	<i:view ... (do not edit) ... type="edit">

	...

	</i:view>


### The &lt;i:title&gt; element	{#edit-title-element}


This is a shared element used by all kinds of Views to define the title of a View. It has no attributes and the values are simply displayed in the title row. The tag supports both static values and placeholders.

	<i:title>My View</i:title>


### The &lt;i:datasource&gt; element	{#edit-datasource-element}

The purpose of this tag is to define a data source to be used when working with already existing data (in edit mode). You need to define three things, as shown in the example below:

1.	The type of data source
2.	The class name
3.	The method name 

Optionally, you may also define a set of parameters for the method.

	<i:datasource type="orm">
		<i:class>MyClass</i:class>
		<i:method name="MyMethod" >
			<i:param name="id">{id}</i:param>
			<i:param name="num">322</i:param>
		</i:method>
	</i:datasource>


In regards to Edit and Show Views, the type of attribute of the ***&lt;i:datasource&gt;*** element must always be "orm" or "static", since the only supported source (at the moment) is a database. Please note that this will be changed in the near future and support for other sources will be added.

The ***&lt;i:class&gt;*** element defines the PHP class to be used. Its value is always the class name. The ***&lt;i:method&gt;*** element defines the method to be called and (optionally) the arguments to be passed to that method. These arguments can be listed using the ***&lt;i:param&gt;*** element.

Please note the order of ***&lt;i:param&gt;*** tags is important, since the arguments will be passed to the method in that exact order. A name must be provided for each parameter only to allow AppFlower to store the corresponding value.

When processing the datasource definition, AppFlower will try to call MyClass::MyMethod(), passing any parameters defined in the ***&lt;i:param&gt;*** element. This means MyMethod() should be declared as a "public state", since AppFlower won't create an instance. The expected result of this call is a Propel object, which is used to fill in your form fields values automatically. If the record cannot be found, the method should return to Boolean false. 

The result can be retrieved by any method, including the following, which is used in most of the typical configurations.:


	<i:datasource type="orm">
		<i:class>MySomePeer</i:class>
		<i:method name="retrieveByPk" >
			<i:param name="id">{id}</i:param>
		</i:method>
	</i:datasource>

 
Another possible alternative is the MySomePeer::doSelectOne() method, but any custom method can be used, as long as the result is either a Propel object or boolean false.

Other Views (such as the List View) support other data sources and also make use of the ***&lt;i:datasource&gt;*** element. For detailed information about other supported data source types, please see List View.

As you can see, the ***&lt;i:params&gt;*** element supports placeholders besides static values; this also applies to ***&lt;i:class&gt;*** and ***&lt;i:method&gt;*** elements.


### The &lt;i:fields&gt; element	{#edit-fields-element}

In an Edit View, this element is the AppFlower counterpart of the XHTML Form. It has many attributes, but most of them are optional and have default values. The only mandatory attribute is "URL", which defines the action of the Form and its value must be a Symfony internal URI-normal URLS are not accepted.
 
The ***&lt;i:fields&gt;*** element may contain any number of ***&lt;i:field&gt;*** tags. These are the building blocks of the AppFlower Form. Other tags  may also be used here, which will also be rendered as form elements, but (for several reasons) have been implemented as separate tags.

The following tags can be placed in an ***&lt;i:fields&gt;*** collection:

Field             |  Description
--------------    |  -----------
&lt;i:field&gt;   |  a form field, see next section for details
&lt;i:button&gt;  |  a normal button
&lt;radiogroup&gt;|  a group of radio buttons 

Here's some information on the important characteristics of the ***&lt;i:fields&gt;*** tag:

When submitting the Form, the data will be posted to the URL defined by the "URL" attribute. By default, the post request is performed by AJAX. This behavior can be changed by setting the "classic" attribute to "true", in which case a normal POST request will be performed.

Like XHTML Forms, the AppFlower fields container can POST both textual and binary data. If you need to design a file upload Widget, set the "multipart" attribute to "true".

Another useful attribute is "redirect". If defined, its value must be an internal URI. The client's browser will then be redirected to this location upon successful submission.

To set the width of the area containing the label of a form field, use the "labelWidth" attribute. Make sure you provide a value in pixels (without the "px" extension).

Finally, unlike XHTML Forms, the fields container does not have a "method" attribute. Instead, data transfers are always performed as POST. This restriction was added due to security reasons.


	<i:fields url="MyModule/MyAction">
 		<i:field name="myField" label="My label" />
 		...
 		<i:button name="myButton" label="My button" />
	</i:fields>


### The &lt;i:field&gt; element	{#edit-field-element}

This tag defines an input field that can be used as part of a Form. The element resides inside of the ***&lt;i:fields&gt;*** tag.

It has many attributes; most of them are optional and have default fixed values. The mandatory ones are listed below:

 * name
 * label

The former is the name of the element (which must be unique) and the latter defines the text to be rendered as a field label.


	<i:field name="id" label="Id" type="hidden" ...>
		....
	</i:field>


However, there are many useful, optional attributes that you should know about. The following list contains these and their descriptions:

 * **type** This determines the type of the input field. Its default value is "input", which is the same as XHTML's ***&lt;input type="text"&gt;*** setting. Currently, a number of input types are supported by AppFlower.

Many of these types are using the same names as their XHTML counterparts and they render the same result as well.:

 * input                                
 * textarea
 * checkbox
 * hidden
 * password
 * radio
 * file
 * combo (same as XHTML &lt;select&gt;)
 * multicombo (same as XHTML &lt;select multiple="true"&gt;)

Apart from these standard types, AppFlower also supports a set of advanced input types, which are unavailable in XHTML:

 * **Date** Displays a date selector Widget.

 * **Datetime** Displays a combined date and time selector.

 * **Doublemulticombo** Rendered as two multicombos side by side. The first contains all items. The second contains only selected items. An interface is provided for moving items between the two and can also be used to change their position. Drag and Drop functionality is supported.

 * **Doubletree** This is similar to the doublemulticombo, but instead of combos, it uses tree-structured lists. This also supports Drag and Drop, and you can move nodes (or groups) freely between the two trees. 

 * **Static** This is not actually a real input field, because it has no interactive features. Instead, it will render a piece of information as plain text (or HTML). In the meantime, it is a form field and acts like such in many ways (regarding grouping, ordering, having the same basic properties, etc.). This kind of field is meant to be used as a tool for printing (formatted) info on forms, but without losing the form field characteristics. Its value won't be posted.

 * **ExtendedCombo**
 * **ExtendedDayTimeSelect**
 * **ItemSelectorAutoSuggest**
 * **RemoteComboAutoSuggest**


 * **state** The actual state of the field. It is editable by default, which means the users can interact with the field and may change its value. It can be set to "read only" (users cannot interact with the field), or to "disabled" (similar to "read only", but rendered differently and the field's value won't be posted).

 * **Style** CSS code may be provided to change the appearance of the field.

 * **Width and Height** These values are automatically calculated by default. You can override this behavior by providing static values in pixels.

 * **rich** This only has a meaning in case of type="textarea". If set to "true", a WYSIWYG editor will be rendered instead of a normal text area.

You can find the rest of the optional <i:field> attributes and their descriptions in Appendix A.


### Children of &lt;i:field&gt;	{#edit-children-of-field}

Most of the parameters of the ***&lt;i:field&gt;*** are defined as attributes, which are listed above. The rest of them are child elements of the node, as they can be verbose in nature and therefore, it is a better way to declare them. This also makes the ***&lt;i:field&gt;*** declaration shorter and more readable.

Please note the order of these elements is important and while all are optional, if you use any of them you must place them in the right order. The following table shows the expected order and number of allowed occurrences.

Field		 | Occurances
-------------| -----------	
&lt;i:value&gt;	 | 0 - 1
&lt;i:tooltip&gt;	 | 0 - 1
&lt;i:help&gt;	 | 0 - 1
&lt;i:validator&gt;| 0 - any
&lt;i:handler&gt;  | 0 - any
&lt;i:window&gt;   | 0 - 1
&lt;i:trigger&gt;  | 0 - 1 (must be present if the previous one is used)

Let us check out these tags and their usage one by one now:


### The &lt;i:value&gt; element	{#edit-value-element}

This tag specifies the value of the field. Usually, this comes from a database, but it's also possible to define static values in XML. The tag has three different forms, of which you may use any that fit your needs.

**1. The general way:**


	<i:field name="id" label="No.">
		<i:value type="orm"> 
			<i:source name="getId" /> 
		</i:value>	
	</i:field>


This is the most widely used variant (and also the shortest one). In this case, the value is returned by a method of the object fetched by the ***&lt;i:datasource&gt;*** statement. In the example above, we call the getId() method. As you can see, this was designed to work with Propel database objects, but you can use any kind of object, as long as it provides the public method you refer to here.

**2. Special cases**

Sometimes, the above method is not the right choice because the value stored in the object is not in the format you wish to display. Other times, you may need to display a value that cannot be retrieved from the database. In this case, you can fetch any custom value by providing a class name and method to call. You can use any class, as long as the method is declared as public static in that class.


	<i:value type="orm">
		<i:class>MyClass</i:class>
		<i:method name="getMyValue">
			<i:param name="example">some value</i:param>
		</i:method>
	</i:value>


As you can see, you may define the class name by using the ***&lt;i:class&gt;*** element. The method called is defined by the ***&lt;i:method&gt;*** element and its "name" attribute must hold the name of the method. If your function requires arguments, then you can pass those using the ***&lt;i:param&gt;*** element. The arguments will be passed in the order you define them here.


**3 Static values**

We have limited support for these, as it's currently possible to define such values for combo and multicombo fields. However, it will be extended in the future to allow the defining of static values for any field (with some exceptions where such values are pointless).

To declare the values of a combo, or multicombo, directly in XML, you can use the following syntax:


	<i:field name="menu" label="Menu" type="combo">
		<i:value type="static">
			<i:item value="1">First Item</item>
			<i:item value="2">Second Item</item>
			...
		</i:value>
	...
	</i:field>


The example above will be rendered as a combo with 2 items:

* First Item
* Second Item

The items and their order are defined by the ***&lt;i:item&gt;*** elements. The only mandatory attribute of this tag is "value", which specifies the value of the item, while the nodeValues will be used as labels.


**Return values**

When you use any of the first two syntaxes, you must call a method to fetch a value. The return value of this method will be the value of the ***&lt;i:field&gt;***, which should be a string, or array. The table below lists all field types, with their expected return value format:


Field Type	|	Return value
----------	|	------------
input		|	any string                                
textarea	|	any string
checkbox	|	any string
hidden		|	any string
password	|	any string
radio		|	any string
file		|	any string
		|
date		|	YYY-mm-dd
datetime	|	YYY-mm-dd HH:ii:ss
		|
combo		|	array("value1" => "label1","value2" => "label2")
multicombo      |       array("value1" => "label1","value2" => "label2")
doublecombo	|	array(0 => array("value1" => "label1", "value2" => "label2" ...), 1 => array("value1" => "label1")
doublemulticombo|	array(0 => array("value1" => "label1", "value2" => "label2" ...), 1 => array("value1" => "label1")
doubletree      |	see example below


As you can see, the value of some fields should be returned as an array. This array is either simple (containing items as value => label pairs), or two dimensional (containing two arrays). In the latter case, the first array holds all items; the second array holds any selected items. Both simple and two dimensional arrays can be either numeric, or associative.


	array("value1" => "label1","value2" => "label2")

The above applies to all types, except combo and multicombo.  For these, the selected values must be supplied by the "selected" attribute of the corresponding ***&lt;i:field&gt;*** element, in the following format;


Type		|	Syntax
-----------	|	---------
combo           |	selected="1"
multicombo      |	selected="0,1"
  

Please note that the entries in selected="..." are referring to values form the array of items and NOT the corresponding keys!


The doubletree type is somewhat special, because it requires items to be supplied in a specific format. This is an associative array, with the following structure:


	array("text"=>"Group 1","value"=>"G1","leaf"=>false,"iconCls"=>"folder",
		"children"=>array(
				array("text"=>"Item1","value"=>"item 1","leaf"=>true,"iconCls"=>"file"),
				array("text"=>"Item2","value"=>"item 2","leaf"=>true,"iconCls"=>"file")
				// more items..
				)

	)

In this case, items are stored in groups and each group must have a unique name. The label displayed is defined by the "text" key in every case. The "iconCIs" key should point to a CSS class name, which attaches an icon to the label.


	.folder {
		background-image:url(/appFlowerPlugin/extjs-3/resources/images/default/tree/folder.gif) no-repeat 0 0 !important;
	}


The "leaf" key is associated with a boolean value. It must be set to true if a node has no children, otherwise it should be false.

So, a complete example of a function that returns a result for a doubletree looks something like this:

	{{{
	public static function getDoubleTree() {

		$double_tree_options=array(array("text"=>"Group 1","value"=>"G1","leaf"=>false,"iconCls"=>"folder","children"=>array(array("text"=>"Item1","value"=>"item 1","leaf"=>true,"iconCls"=>"file"),
		array("text"=>"Item2","value"=>"item 2","leaf"=>true,"iconCls"=>"file"))),
		array("text"=>"Group 2","value"=>"G2","leaf"=>false,"iconCls"=>"folder","children"=>array(
		array("text"=>"Item3","value"=>"item 3","leaf"=>true,"iconCls"=>"file"),array("text"=>"Item4","value"=>"item 4","leaf"=>true,"iconCls"=>"file"),array("text"=>"Item5","value"=>"item 		5","leaf"=>true,"iconCls"=>"file"))));

		$double_tree_selected=array(array("text"=>"Group 1","value"=>"G1","leaf"=>false,"iconCls"=>"folder","children"=>array(
		array("text"=>"Item2","value"=>"item 2","leaf"=>true,"iconCls"=>"file"))));
		
		return array
		(
		0 => $double_tree_options,
		1 => $double_tree_selected
		);
	}

 
### The &lt;i:tooltip&gt; element	{#edit-tooltip-element}

Each field may have its own help text, which is rendered when the user moves his mouse over the field (similar to a tooltip).

Such text may be defined (optionally) via the ***&lt;i:tooltip&gt;*** tag, which has no attributes.


### The &lt;i:help&gt; element	{#edit-help-element}

The purpose of the <i:help> element is to provide a short description, or usage instruction, which is rendered directly beneath the field, in an italic, gray font. Like the ***&lt;i:help&gt;*** tag, this has no attributes and is completely optional.


An example of the ***&lt;i:help&gt;*** and ***&lt;i:help&gt;*** tags:


	<i:field name="MyField" label="My">
		<i:value type="static">
		...
		</i:value>
		<i:tooltip>This is the tooltip text</i:tooltip>
		<i:help>Lurem ipsum lorem</help>
	</i:field>

### The &lt;i:validator&gt; element {#edit-validator-element}

AppFlower supports server-side form validation through a series of built-in validators. This means in most cases, you won't have to write any PHP code, since declaring a validator in XML will be enough.

The framework will render validation error messages in a sophisticated way. Related fields will have a red border and the corresponding error message will display each time a user moves his mouse pointer over the field.

The set of validators you can use (without any PHP coding) includes all validators in Symfony 1.2.x. This means you already have the required validation tools for the most frequently used data types, including: strings, numbers, and dates. It also means any custom Symfony 1.2.x style validator will be supported (we support the API), including your own code. 

Please note: AppFlower also provides full support for Symfony 1.0.x style validators, but these are considered deprecated in some newer versions of Symfony 1.2.x; thus, they may fail-even if 1.0.x compatibility is enabled. This applies to certain Symfony 1.2.x version, not all of them, but as a rule of thumb, it's better to use the 1.2.x API.

Apart from these Symfony components, AppFlower provides a few additional validators to make your life easier.

The following is the general syntax of a validator definition:

	<i:field name="ip" label="IP Address" type="input" state="editable" style="css">		

		<!-- value, help and comment definitions... -->
				
		<i:validator name="immValidatorIp" />	
		<i:validator name="immValidatorUnique">
			<i:param name="class">Server</i:param>
			<i:param name="column">ip</i:param>
		</i:validator>
	</i:field>	

The ***&lt;i:validator&gt;*** tag has one attribute: the mandatory "name", which defines the name of the validator class to be used. Child nodes are optional, but you can use them to provide required parameters for a validator. This can be done by adding some ***&lt;i:param&gt;*** elements.

Please note that in regards to validators, the "name" of the ***&lt;i:param&gt;*** is important, since the validator looks up parameters by name.

The example above refers to two validators: one without parameters and another with a "class" and "column" parameter. You may list any number of validators. They will be executed one after another, until one fails (an input error is detected), or the queue is over (all good).

The following example calls a built-in Symfony validator. Note the names of the parameters are the same as those listed in Symfony documentation.


	<i:field name="ip" label="IP Address" type="input" state="editable" style="css">		
	
		<!-- value, help and comment definitions... -->

		<i:validator name="sfValidatorRegex">
			<i:param name="pattern">/^([1-9]+[0-9]*)?$/</i:param>
			<i:param name="invalid_error">Only the valid integer is accepted</i:param>
			<i:param name="required">false</i:param>
		</i:validator>
	</i:field>

 
### Event Handlers - The &lt;i:handler&gt; elements	{#edit-event-handler}

Event handling is supported by AppFlowr and XHTML. In XHTML, the handler can be attached to an element (as an attribute value), but in AppFlower it is a child node of the affected element. The reasons for this are readability and better syntax, especially when many handlers are used at the same time.

In AppFlower, event handlers can be attached to any form field (***&lt;i:field&gt;, &lt;i:button&gt;***, etc.). Also, AppFlower and XHTML both support the same basic events, and more. The current list is below:


You must use the ***&lt;i:handler&gt;*** tag to attach an event handler to an element. It has two attributes and both are mandatory:

 * **Type** The type of event. Its value must be one of the supported types listed above.

 * **Action** The JS code to execute when the event occurs.

The following example creates an ***&lt;i:field&gt;*** with a "click" event handler attached to it:


	<i:button name="button2" label="Script Button" icon="/images/famfamfam/cancel.png" action="test/list">
		<i:handler type="click" action="alert('CLick!');" />
	</i:button>


In this example a form field is created and the "blur" event is attached to it:


 	<i:fields url="/test/action">
  		<i:field name="myField" label="My Field" type="input" state="editable" style="css" >
			<i:handler type="blur" action="alert('Focus has been just removed!');" />	
		</i:field>
		...
  	</i:fields>


### Field bound popups - The &lt;i:window&gt; element.	{#edit-field-bound-popups}

This is the last tag in an ***&lt;i:field&gt;*** declaration and its purpose is special. It allows you to extend the value of the enclosing ***&lt;i:field&gt;*** (or define it, if the field is empty) via a popup window. The tag adds a button to the ***&lt;i:field&gt;***, which opens a new panel and loads an edit View into it. Once you fill in the popup fields, you can submit it and the result will be added to the value of the ***&lt;i:field&gt;*** (the element reloads).

A use case of this is an empty field, whose value cannot be defined when the form is rendered, but it is required to have a proper value upon submit. Another case is a combo (multicombo, etc.) element, which has some items, but the value the user needs cannot be found among them (since it doesn't exist, yet). There are many similar cases. For instance: think of a user data edit Page, with a "user group" field. This tag makes it possible to relate that new user to a new group in one step.

An example of an ***&lt;i:window&gt;*** call follows:


	<i:window title="Server Location Add [Quick Widget]" component="/server/editServerLocation" className="LocationPeer" methodName="getAll" width="900" />		

The tag has four mandatory attributes:

 * **Title** Defines the title text of the popup panel.

 * **Component** The Symfony internal URI that points to the Edit Widget to be called

 * **ClassName** The name of the class used when reloading the related ***&lt;i:field&gt;*** element.

 * **MethodName** The name of the method called when reloading the related ***&lt;i:field&gt;*** element.

The latter two will usually be the same class and method used to render the ***&lt;i:field&gt;*** when the form is constructed.

The tag has two optional attributes; since these are frequently used, we listed them here:

 * **Width** The width of the popup panel in pixels (without the "px" extension). If omitted, the default value will be used, which is 500 pixels.

 * **IconCls** The value is the name of the CSS class and should represent an icon used when rendering the popup opener button. If omitted, a small plus sign (+) will be used.

## The code generator {#admin}

AppFlower has a code generator similar to the Symfony Admin Generator. In fact, it is an extension of the Symfony task, which means the syntax is very similar and it supports most of the same features.

It also contains AppFlower-specific functionality: it supports more options and the YML syntax is different, too.

### The code generator shell task

Just like Symfony, AppFlower also provides a CLI task, which is an automated module builder.

	>> symfony appflower:generate-admin [--module="..."] [--singular="..."] [--plural="..."] [--env="..."] [--no-forms="..."] application model

As you can see, it has almost the same arguments and options as the SF task, but there are a few differences:

* The second argument must be the name of a Model class, routes are NOT supported.
* It has one extra option: **--no-forms**.

The routing names aren't allowed because the generated rules are currently incompatible with AppFlower; however, this restriction should be removed in the near future.

The **-no-forms** option is meant to speed up the building process. By default, the generator builds all **Form and Filter** classes every time you execute it, but if you set this option to "true", the step will be skipped and the process will run a lot faster.
time you execute it. If you set this option to "true", this step will be skipped, thus the process will run a lot faster.

<div class="forbidden" markdown="1">
Please note that the Form and Filter classes **MUST** be generated **at least once**, othewise the generator won't work properly!
</div>. 

Like I said, the rest of the command line options are the same as Symfony's Admin Generator. For more information, please see:

	>> symfony help propel:generate-admin

When the task is executed, it will generate all necessary files (just like in Symfony), including the generator.yml file, which has the default content. This kind of module is **instantly usable** (you can access it in your browser). To define the details, look and feel, you must edit the generator.yml file.


### Generator YML syntax - Basic structure

Although AppFlower uses XML exclusively to describe configuration data, the generator is an exception; in this case, YML is used. The reason for this is the underlying Symfony Admin Generator, which is also YML-based.

The AppFlower task can read and parse the same generator.yml file as Symfony, but the syntax is not completely the same. AppFlower has specific options and subsections, while some Symfony options are not yet supported, due to incompatibilities with AppFlower.

The structure of the YML file expected by AF is as follows:

	generator:
	  class: sfPropelGenerator
	  param:
	    model_class:           Ticket
	    theme:                 appFlower
	    non_verbose_templates: true
	    with_show:             false
	    singular:              Ticket
	    plural:                Tickets
	    route_prefix:          ~
	    with_propel_route:     false
	    actions_base_class:    sfActions
	    default_actions: true
	    pager:           true
	
	    config:
	      actions: ~
	      fields:  ~
	      list:
	        title: 
	        scripts:
	        credentials:
	        fields:
	        display:
	        hide:
	        sort:
	        max_per_page:
	        batch_actions:
	        object_actions:
	        actions:
	      filter:  ~
	      form:
	        title:
	        scripts:
	        credentials:
	        fields:
	        display:
	        values:
	        handlers:
	        validators:
	        actions:
	      edit:    ~
	      new:     ~

As you can see, most of the global parameters are the same, we have only two new values and the "with_propel_route" is always false, due to
the unsupported routing.

The two new params are:

* default_actions
* pager

**default_actions**

This is a boolean value, true by default. If it's enabled, the generator will add some actions automatically to the List and Edit / Show
views:

**List View Actions**

* Delete all
* Delete selected

**Edit View Actions**

* Add new item

These are automatically added and you cannot change their attributes later. If you wish to define these actions manually, set this option to "false".

**pager**

This is also a boolean value. When set to "true", the List View is pageable; otherwise, the paging controls are removed.

### Generator YML syntax - Config sections

As for the keys listed under "config" (the content part), you can use all subsections supported by the Symfony task, but not all of them will be used by AppFlower.

Why? Well, first of all, the AppFlower generator only uses the main **fields**, **list**, and **form** sections.

This is because the others are not compatible with AppFlower's design. We don't have a separate create/edit mode, so there is no need for the edit and new sections. The actions section is also unnecessary, because in AppFlower the Edit and List Views don't have any actions in common. The filters section is also ignored, because AppFlower provides this functionality out-of-the-box.

Regardless of these things, you can still use the keys. They will be recognized by the Symfony task and safely ignored by the AppFlower generator.

<div class="forbidden" markdown="1">
Please note: while you may use all the Symfony generator options in AppFlower's generator.yml, **it won't work the other way around!** The Symfony generator will only validate the YML **content**; it won't recognize the AppFlower-specific data!
</div>

**fields**

This should contain the **global** definition of the list columns and form fields (like in Symfony). Inheritance is supported, so you can redefine any of the fields (or columns) under either the **list**, or the **form** subsections. Those rules will override the global declarations.

It is also valid to redeclare only a part of the rule, in which case the generator will only update the
original definition.

**list**

It should contain all List View specific declarations

**form**

The Edit / Show View specific definitons should be placed here.


### Generator YML syntax - Options 

Options are the actual definitions allowed in the generator.yml file, located under "config" and its subsections.

AppFlower supports most options used by the Symfony task; incompatible options are safely ignored.

Aside from these, you can use any AppFlower attribute in field (or column) definitions.

We will list the AppFlower-specific options below, as well as those with different implementations in the AppFlower generator, or are simply not supported by AppFlower. The latter will be printed in <span class="red" markdown="1">red</span>.

You can find the rest of the options in the Symfony documentation:

[http://www.symfony-project.org/reference/1_4/en/06-Admin-Generator](http://www.symfony-project.org/reference/1_4/en/06-Admin-Generator) 

### Options for fields section

**help**

This is the same as Symfony's options, but the AppFlower generator transforms this into an **&lt;i:help&gt;** element, whose rendering depends on the user's help settings.

<span class="red" markdown="1">
attributes
</span>

This is not supported by AppFlower, but you can use the **style** attribute of the **&lt;i:field&gt;** element, which as the same purpose.

 	fields:
      name: {label: Name, style: "width: 200px; color: blue" }

<span class="red" markdown="1">
credentials
</span>

The original purpose of this was to allow you to hide certain actions, or form fields, based on user credentials.

However, AppFlower doesn't support hiding form fields (yet); so, it implements this as a subsection of **list** (or **form**) and applies the given credentials to the corresponding view. 

See *form* or *list* for details.

**renderer and renderer_arguments**

AF allows you to override the field's value using this declaration. The syntax is the following:

	fields:
      name: {label: Name, help: foo, renderer: { type: orm, class: Util, method: getFoo2, default: some }, renderer_arguments: {foo: 7, bar: 2} }

As you can see, you can specify a class and a method of that class will be called to fetch the field's value. Arguments of the method can be
passed via renderer_arguments.	

**type**

AF expects a valid **&lt;i:field&gt;** input type.

**date_format**

This is supported, but instead of using the formatting parameters of PHP's date function, you must use ExtJS formatting options. Please see the following URL for details (click "Date").

[http://dev.sencha.com/deploy/dev/docs/](http://dev.sencha.com/deploy/dev/docs/)

<div class="warning" markdown="1">
Please keep in mind that in addition to these options, you can use **ALL AppFlower attributes** in your field declarations!
</div>


### Options for list section

**batch_actions**

Actions listed under this subsection are transformed into **&lt;i:moreactions&gt;**.

**credentials**

As stated above, this is implemented as a subsection of **list**. If the user doesn't have the listed credentials, the List View won't be rendered. The syntax is the same as in Symfony's generator.

	list:
      credentials: [[ fofo, admin, defe ]]

To hide an action (instead of setting credentials for the view), use the AppFlower **condition** attribute:

	actions:
      new: { label: Add new Stuff, url: "/lele/edit", iconCls: icon-plus, condition: "User:hasRights()" }

**scripts**

This is an AppFlower addition. The JS files listed here are preloaded during parsing, so the code is available after rendering.

	list:
      scripts: [myscript,anotherfile]

<div class="forbidden" markdown="1">
Please note: The files **must** be listed **without** the JS extension!
</div> 

The following options are not supported by the AppFlower generator. This is either because AppFlower doesn't have the necessary API to implement them yet, or it is simply incompatible with them:

Option  |  
------  |
layout  |
params  |
pager_class |
peer_method |
peer_count_method |
table_method |
table_count_method |


### Options for form section

<span class="red" markdown="1">
class
</span>

It's not supported yet.

**title**

The title text of the Edit / Create / Show View.

**display**

It's the same as in Symfony's generator, with the exception of a few minor differences.

Since AppFlower suppots tabbed forms, you can make your form use tabs by placing a plus (+) sign before the fieldset title.

If you want to render the fields with floating enabled, add the minus (-) prefix to the fieldname in the field list:

	display:
      "+Set1": [title,-type_id,user_id,-owner_id,details]
      "+Set2": [hours_estimated,is_public]  

The above example creates a tabbed view. The fieldset "Set1" will contain 5 fields, 2 in each row (except for the last one).

**scripts**

It's the same as in the **list** section.

**values**

This is another AppFlower addition. It is a subsection that allows you to override the value of a field, or specify a default value.

The default value is only used in "create mode" (when the Widget is called without the "id=" part); otherwise, the method of the class you refer to is called.

	values:
      due_at: { type: orm, class: Util, method: getFoo2, default: "1978-01-31 00:00:00" }

It's possible to define the value as "static". In this case, the form field is always rendered using this value, regardless of mode (edit or create). The value is constant and cannot be changed later.

	values:
      due_at: { static: foo }

**handlers**

This is another AppFlower addition. It is a subsection that allows you to attach JS event handlers to form fields. The syntax is straightforward and the declaration is transformed into **&lt;i:handler&gt;** elements.

The "type" should be a valid AppFlower event handler. The "action" contains the JS code to be executed when the event occurs.

	handlers:
      name: [ { type: blur, action: alert(1)} ]

You may define multiple handlers for a form field, but they must have different types.

**validators**

This is also available only in AppFlower. You can specify a set of validators here, which will be used to validate the corresponding form field.

The declaration is transformed into a number of **&lt;i:validator&gt;** elements.

You can specify which validator you want to use with the "name" key and pass arguments to it using the "params" key.

	validators:
      name: [ { name: immValidatorRequired, params: {foo: bar, bar: 1} } ]


You may define multiple validators for a form field.

### Generator YML syntax - a complete example

Below, you'll see an example of the generator.yml file, which contains most of the options described above.

	generator:
	  class: sfPropelGenerator
	  param:
	    model_class:           TicketMilestone
	    theme:                 appFlower
	    non_verbose_templates: true
	    with_show:             false
	    singular:              ~
	    plural:                ~
	    route_prefix:          ~
	    with_propel_route:     false
	    default_actions:       true
	    pager:                 true
	
	    config:
	      actions: ~
	      fields:
	        name: {label: Name }
	        project_id: {label: Project2, align: left }
	        hours_estimated: {label: Hours, link: "true" }
	        due_at:  {label: Due At }
	        id:  {label: Lala }
	      list:
	        credentials: [[ fofo, admin, defe ]]
	        hide: [project_id,name]
	        scripts: [sayhi]
	        title: lala
	        actions:
	          new: { label: Add new Stuff, url: "/lele/edit", iconCls: icon-plus }
	          other: { label: Do Something, url: "#", script: alert(2323), iconCls: icon-plus }
	        batch_actions:
	          lala: { label: Foo, url: "lele/bar"}
	        object_actions:
	          pipi: { url: "#", script: alert(1), iconCls: icon-plus }
	          pipa: { url: "#", script: alert(1), iconCls: icon-minus }
	      filter:  ~
	      form:
	        title: Foobar Foo!
	        credentials: [[ fofo, ubu, defe ]]
	        fields:
	          name: {label: Name, help: foo }
	          project_id: {label: Project, help: zip, type: combo }
	          hours_estimated:  {label: Hours, help: lala, tooltip: bar }
	          due_at: {label: Due At, type: date, date_format: "y/m/d H" }
	        actions:
	          another: { label: The list, url: "lele/list"}
	        display:
	          "+Set1": [project_id,name]
	          "+Set2": [hours_estimated,due_at]
	        validators:
	          name: [ { name: immValidatorRequired } ]
	          project_id: [ {name: immValidatorRequired } ]
	        values:
	          due_at: { type: orm, class: Util, method: getFoo2, default: "1978-01-31" }
	          hours_estimated: { type: orm, class: Util, default: 10, method: getFoo, params: {foo: 1, bar: 2} }
	        handlers:
	          name: [ { type: blur, action: alert(1)} ]
	          project_id: [ { type: blur, action: alert(2)} ]
	      edit:    ~
	      new:     ~

 


## Other elements inside &lt;i:fields&gt;	{#other-elements-inside-fields}

### The &lt;i:button&gt; element	{#button-element}

This is how you define submit, reset, or normal buttons. The mandatory attributes are the same as that of ***&lt;i:field&gt;*** (name and label) and the most important (optional) ones are listed below:

 * **Type** This determines the purpose of the button (reset, submit, or normal). A normal button may call an URI, or execute the JS code defined by one of its handlers.

 * **Icon and IconCls** This allows users to attach an image to the button. The image is rendered as an icon, on the left side of the button. The value of the former attribute should be an absolute path, such as "/usr/www/myapp/web/images/foo.png", while the latter expects the name of a CSS class.

 * **Action** The value of this must be an internal URI, or a standard URL. Clicking the button will call this address via a GET request. If the type="submit", then the form will go through the POST action.

 * **Updater** This is a boolean value, which is set to "false" by default. When set to "true", the button initiates a comet-like request and responses pushed back by the server will be rendered in the form of a dialogue with a progress bar. This is also useful for making more responsive applications.


The following creates a button, which loads the "test/show" Symfony action when clicked:

	<i:button name="button" label="Click Me" icon="/images/famfamfam/cancel.png" action="test/show" />

This other button performs the same action as the previous one, but before loading "test/show", it will execute some JS code.

	<i:button name="button2" label="Click Me" icon="/images/famfamfam/cancel.png" action="test/show">
		<i:handler type="click" action="alert('You clicked me!');" />
    	</i:button>

### The &lt;i:link&gt; element	{#link-elemenet}

You can use this tag in Edit, Show, and HTML views. It does exactly what you expect it to: it places a textual hyperlink, much like the ***&lt;a&gt;*** tag in XHTML. It has three mandatory attributes:
  
 * **Name** This is a unique name for the link.

 * **Action** This is the URL it points to. It can be a normal URL, or an internal URI.

 * **Text** This is the link text.

Example

	
	<i:link name="lnk1" text="Click Me" action="test/show" />
	
	

### Arranging fields - The &lt;i:grouping&gt; element {#arranging-fields-element}

Inside the ***&lt;i:fields&gt;*** tag, you may add the elements in any order and (by default) the fields are rendered in that order. To define a custom order, you must use the ***&lt;i:grouping&gt;*** element, which is always the last tag in an Edit View.

Let us consider the following example:


	<i:grouping>
		<i:set title="Basic Settings">
			<i:ref to="id" />
			<i:ref to="ip" />
			<i:ref to="name" />
			<i:ref to="server_type_id" />			
			<i:ref to="server_group_id" />
		</i:set>
		<i:set title="Additional">
			<i:ref to="hostname" />
			<i:ref to="location_id" />
			<i:ref to="customer_id" />
		</i:set>
	</i:grouping>


As you can see, the enclosing tag doesn't have any mandatory attributes; however, it does contain ***&lt;i:set&gt;*** elements and those contain ***&lt;i:ref&gt;*** tags.

When this is rendered, the fields of the form are placed into two field sets: "Basic Settings" and "Additional", respectively. The fields are rendered in the order of the ***&lt;i:ref&gt;*** elements. The "to" attribute of the ***&lt;i:ref&gt;*** element must point to one of the ***&lt;i:field&gt;*** tags. The "name" attribute of the latter must match the "to" attribute of the former.

In AppFlower Forms, all fields belong to a field set, even if the ***&lt;i:grouping&gt;*** tag is not used. In this case, one field set will be rendered containing all fields. The default title of this is "Default", but you can override this anytime by adding a "title" attribute to the ***&lt;i:grouping&gt;*** element.

Let us discuss the contents of ***&lt;i:grouping&gt;*** in detail. 

### Field sets - The &lt;i:set&gt; tag {#field-sets}

An AppFlower field set looks the same as its XHTML counterpart. It has one mandatory attribute: the "title", which must always be defined. However, it's the only basic behavior and the AppFlower field set has more to offer. It can be divided into any number of columns, which means you can display the related fields in any layout. You can also render a field set as a tab and therefore, complex tabbed views can be built.

Each field set is displayed, by default. If you wish to hide one, set its "collapsed" attribute to "true". The set will then be displayed in a collapsed state, but users can still open it anytime. This is very useful when you need to render some extra (or optional) fields.
 
To splits a field set into columns, you must set the "float" attribute of the ***&lt;i:set&gt;*** element to "true". Then, simply add a "break" attribute to the ***&lt;i:ref&gt;*** tags that should be the last items of their column. For example: to create a two row/two column field set (with 2 fields in each row), you would do this:


	<i:grouping>
			<i:set title="Basic Settings" float="true">
			<i:ref to="id" />
			<i:ref to="ip" break="true" />
			<i:ref to="name" />
			<i:ref to="server_type_id" break="true" />			
		</i:set>
		<i:set title="Description">
			<i:ref to="body" />
		</i:set>
	</i:grouping>

Please note that it is not important to distribute field references evenly between columns. If a column contains 2 ***&lt;i:ref&gt;*** tags and the next column has 3 tags, then something like the "colspan" attribute used in XHTML tables will be calculated automatically. Different fieldsets may have their own unique layout, with any number of columns (including 0), since they are not related to each other in this sense (unlike TDs in XHTML tables).

As shown in the example, it is okay to mix floated and non-floated fieldsets. You could define 2 floated sets, then 1 normal (non-floated) set, then another floated set; there is nothing wrong with this. They are all rendered according to their own model.

To transform a fieldset into a tab, all you must do is define the "tabtitle" attribute. Please consider the following example:


	<i:grouping>
		<i:set title="Description" tabtitle="Description">
			<i:ref to="body" />
		</i:set>
		<i:set title="Additional" tabtitle="Additional">
			<i:ref to="hostname" />
			<i:ref to="location_id" />
			<i:ref to="customer_id" />
		</i:set>
		<i:set title="Permission" tabtitle="Permission">
			<i:ref to="object_permission_id" />
		</i:set>
	</i:grouping>

This will build three tabbed fieldsets. In other words, three tabs are created: "Description", "Additional", and "Permission", and these will hold the fieldsets.

The height of a tab can be changed via the "tabHeight" attribute. You can also attach an icon to the tab, similar to the way you do with buttons. However, only the "iconCIs" attribute is supported here; you cannot use the "icon" attribute.

Tabbed and normal fieldsets can be mixed. So, in the previous example I could remove the third tab's tabtitle, which would render it as a normal fieldset, while the other two would remain tabs.

Making a normal fieldset tab is completely unrelated to its layout. Therefore, you can use tabs with any configuration of columns, or with normal sets, it doesn't make a difference. 
